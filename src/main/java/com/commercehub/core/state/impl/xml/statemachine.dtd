<?xml encoding="UTF-8"?>
<!-- Created by Orr Bernstein -->
<!-- Names may not contain whitespace or the following set of character '.,[]'. -->
<!-- Root element for state machine definitions. 
     
     One state machine should be defined for each stateful payload type in each 
     business process.  Currently, Hub profiles do not correspond to business 
     processes in 1-to-1 fashion, so it is expected that multiple state machines 
     will be defined for each merchant profile.
     
     Note that the profile is not identified in the state machine definition; it
     is the responsibility of profiles to name the state machine(s) they use.
     
     The name of the state machine is the name of the root state.  It is not
     permitted for multiple state machines to share the same name for the same
     stateful payload type in the same profile.
     
     Transitions, naturally, cause new states to become active, which in 
     turn expose new transitions.
-->
<!ELEMENT state-machine ((state | trigger-map | property |transition)*)>
<!ATTLIST state-machine
        name CDATA #REQUIRED
        concurrent (true | false) "true"
        description CDATA #IMPLIED
        default-child-ref CDATA #IMPLIED
>
<!-- A state may have any number of child states. 

     A state may have any number of transitions to other states or to itself.

     A state may be "concurrent":  
        When a concurrent state is active, all of its immediate child states are 
        active.  
        Concurrent states are useful for implementing submachines.  
        Any transition to or from any of the descendents of a concurrent state 
        must be from or to a descendent of that state; i.e., it is not permitted 
        to transition into or out of a submachine.

    A state may have a default immediate child state, denoted by the
    default-child-ref attribute:  
        If the state has no history (i.e. the value of the history attribute is 
        'none' or the state has never before been active), then the default 
        child will become active when the state becomes active.  
        It is permitted for a state to have no active child.
        Note that the notion of default child is irrelevant for concurrent
        states; all of their immediate children are activated when the state 
        becomes active.

    A state may keep history:  
        If the value of the history attribute is 'self', when the state is 
        deactivated it will remember which of its immediate child states (if 
        any) was active; that child will be reactivated if necessary when the 
        state next becomes active.  
        If the value of the history attribute is 'deep', this behavior extends 
        throughout all descendents of the state.  
        Note that self-history is irrelevant for concurrent states; all of their 
        immediate children are activated when the state becomes active.
        If the value of the history attribute is 'none', it has no knowledge of 
        anything that occurred in the past.  When the state is activated, its
        default child (if any) will be activated.

    No states may have the same parent and the same name.  States with different
        parents may have the same name.
-->
<!ELEMENT state ((state | transition | entry-action-ref | entry-set-property | exit-action-ref | exit-set-property)*)>
<!ATTLIST state
        name CDATA #REQUIRED
        concurrent (true | false) "false"
        default-child-ref CDATA #IMPLIED
        history (none | self | deep) "none"
>
<!-- Transitions control the activation of other states.  They are the result of
     triggers and represented as child elements of states.  
     
     If the exit state (the transition element's parent state) is exclusive to 
     the entry state, it will be deactivated.  If the exit state is concurrent 
     with the entry state, both entry and exit will be active after the transition.
     
     A transition from a state to itself or a state to one of its ancestors 
     should not alter activeness and is essentially a non-operation.

     Transitions must be named so that triggers may be mapped to them by
     trigger-map elements.

     The 'entry' attribute of a transition element identifies the state that will
     be activated when the transition is executed.  The value of this attribute
     must be a complete, fully-qualified, dotted-notation path name of the
     entry state.

     Transitions may have trigger-ref children.  These cause the transition to
     execute when the referenced trigger is pulled, if it qualifies according to
     the parameter of the mapping.
        trigger-ref children may be used regardless of whether a trigger-map
        is also used to map triggers to this transition.
        When triggers are mapped to transitions with trigger-ref elements, there
        is no guarantee of ordering of transitions when a single trigger
        causes multiple transitions to execute.  Trigger-mapped transitions will 
        always execute before trigger-reffed ones.

     Transitions may have transition-action-ref children.
        The actions will be executed when the transition occurs, in the order
        they are listed.
        Transition actions occur after all necessary deactivations occur and
        before the necessary activations occur.
-->
<!ELEMENT transition ((trigger-ref | transition-action-ref | transition-set-property | state-rank)*)>
<!ATTLIST transition
        name CDATA #REQUIRED
        entry CDATA #REQUIRED
>
<!-- Trigger-ref elements are children of transition elements; they map a 
     trigger to their parent transition.  
     The ref attribute is the name of a trigger defined by a trigger-defn 
     element.  The trigger-defn may exist in a separate file.
     The param attribute specifies the parameter value that must be supplied
     by the application when it pulls the trigger for the trigger to qualify
     to cause the transition to execute. 
     The value may be absent or empty.  In either case, a null or empty
     string value of the runtime argument to eval(...) will qualify the
     trigger to execute the transition.
     The value may be "*".  In this case, any parameter value will qualify
     the trigger to execute the transition.
     The value may be an explicit string.  In this case, only that explicit
     parameter value will qualify the trigger to execute the transition.  The
     test will be case-insensitive.
-->
<!ELEMENT trigger-ref  (condition?)>
<!ATTLIST trigger-ref
        ref CDATA #REQUIRED
        param CDATA #IMPLIED
>
<!-- State-rank elements are used to help differentiate between Stateful 
        instances when an external event could trigger multiple siblings 
        to transition.
        
        A state receives rank based on order of definition, with the first
        defined element receiving a rank of zero.  States that do not appear 
        in the rank declaration will be valued arbitrarily, but are guaranteed to
        receive a higher rank than anything defined in the list.
        
        Note that in the case of concurrency, the lowest rank of any defined and
        active states will be returned.
        
        It is left to clients to decide whether high or low rank is preferred.
-->
<!ELEMENT state-rank EMPTY>
<!ATTLIST state-rank
        ref CDATA #REQUIRED
>
<!-- An entry-action-ref element maps an action to a state.  The ref attribute 
     is the name of an action defined by an action-defn element.  The 
     action-defn may exist in a separate file.

     Entry actions are executed when their parent state becomes active.  In the
     case of a self-transition, the state's entry actions are executed at the
     end of the transition, regardless of whether the implementation actually 
     deactivates the state during the transition.

     Entry actions are executed in the order listed.
-->
<!ELEMENT entry-action-ref EMPTY>
<!ATTLIST entry-action-ref
        ref CDATA #REQUIRED
        param CDATA #IMPLIED
>
<!-- A entry-set-property element maps a property value-set to a state entry. 
        The name attribute is the name of a property assigned in a
        property child element.  The value is the text of a value element 
        contained in the property named.  Please note that specifying a property 
        name or a value that is not listed it will not be considered in
        error, but is bad form as these values will not be enumerated anywhere.
                
        Property sets are implemented as a special case state action and thus are
        executed in the order listed and in the same queue as entry-action-refs.
-->
<!ELEMENT entry-set-property EMPTY>
<!ATTLIST entry-set-property
        name CDATA #REQUIRED
        value CDATA #IMPLIED
>
<!-- An exit-action-ref element maps an action to a state.  The ref attribute is 
     the name of an action defined by an action-defn element.  The action-defn 
     may exist in a separate file.

     Exit actions are executed when their parent state becomes deactivated.  In 
     the case of a self-transition, the state's exit actions are executed at the
     start of the transition, regardless of whether the implementation actually 
     deactivates the state during the transition.

     Exit actions are executed in the order listed.
-->
<!ELEMENT exit-action-ref EMPTY>
<!ATTLIST exit-action-ref
        ref CDATA #REQUIRED
        param CDATA #IMPLIED
>
<!-- A exit-set-property element maps a property value-set to a state exit. 
        The name attribute is the name of a property assigned in a
        property child element.  The value is the text of a value element 
        contained in the property named.  Please note that specifying a property 
        name or a value that is not listed it will not be considered in
        error, but is bad form as these values will not be enumerated anywhere.
                
        Property sets are implemented as a special case state action and thus are
        executed in the order listed and in the same queue as exit-action-refs.
-->
<!ELEMENT exit-set-property EMPTY>
<!ATTLIST exit-set-property
        name CDATA #REQUIRED
        value CDATA #IMPLIED
>
<!-- A transition-action-ref element maps an action to a transition.  The ref
     attribute is the name of action defined by an action-defn element.  The
     action-defn may exist in a separate file.

     Transition actions are executed in the order listed.
-->
<!ELEMENT transition-action-ref EMPTY>
<!ATTLIST transition-action-ref
        ref CDATA #REQUIRED
        param CDATA #IMPLIED
>
<!-- A transition-set-property element maps a property value-set to a 
        transition.  The name attribute is the name of a property assigned in a
        property child element.  The value is the text of a value element 
        contained in the property named.  Please note that specifying a property 
        name or a value that is not listed it will not be considered in
        error, but is bad form as these values will not be enumerated anywhere.
                
        Property sets are implemented as a special case state action and thus are
        executed in the order listed and in the same queue as 
        transition-action-refs.
-->
<!ELEMENT transition-set-property EMPTY>
<!ATTLIST transition-set-property
        name CDATA #REQUIRED
        value CDATA #IMPLIED
>
<!--                           
     Condition is a special-case element used for "rolling up" state changes
     between obseved objects.  Conditions are evaluated similarly to, but
     separately from, parameters.
     
     Conditions are specified in terms of enumerations of their childrens'
     states.  The condition "ALL(open.split)" is true only if all child objects
     are in an open.split state, and thus this trigger will only fire 
     transitions if that is the case.  Conditions can contain lists of possible
     states, and will be met if any of these states is active on the children.
     Therefore "NONE(new,open)" would evaluate that none of the children was in
     a new or open state.
     
     Possible enumerations include:
        ALL()  all children are in one of the enclosed states
        ANY()  at least one child is in one of the enclosed states
        SOME()  more than one, but not all, children are in the enclosed states
        NONE()  none of the children is in any of the enclosed states.
     
     Furthermore, you can separate enumerations with logical operators  AND,
     OR and NOT()  and enclose clauses in parenthesis ().  Put them all
     together, and you get this:
        NONE(new,shipping) AND (ANY(shipped-partial) OR SOME(shipped-complete))
-->
<!ELEMENT condition (#PCDATA)>
<!-- A trigger-map element maps a single trigger to any number of transitions.

     The differences between trigger-map and trigger-ref are:
        trigger-map elements are children of the top-level state-machine
        element
        The transitions listed in a trigger-map are guaranteed to execute in
        the order listed when the trigger is pulled.

     A trigger-map element has the same attributes as a trigger-ref; see their
     descriptions there.
-->
<!ELEMENT trigger-map (transition-ref*)>
<!ATTLIST trigger-map
        ref CDATA #REQUIRED
        param CDATA #IMPLIED
>
<!-- transition-ref elements are used as children of trigger-map elements; they
     define the transitions that will execute when the trigger is pulled and
     qualifies.
-->
<!ELEMENT transition-ref (condition?)>
<!ATTLIST transition-ref
        ref CDATA #REQUIRED
>
<!-- Stateful objects have properties - status, substatus, and the like -
        that can be set based on transitions and state entry/exit.  The property
        element identifies a property of a stateful object and enumerates all 
        possible values, decoupling the stateful implementation from its control 
        data.  The default-value will be set upon the initial integration of a
        stateful with its state-machine; if no default is provided, no value will
        be set for this property during state machine initialization.
-->
<!ELEMENT property (value*)>
<!ATTLIST property
        name CDATA #REQUIRED
        default-value CDATA #IMPLIED
>
<!-- A possible value for a given property.
-->
<!ELEMENT value EMPTY>
<!ATTLIST value
        text CDATA #REQUIRED
        description CDATA #IMPLIED
>
